В исходной программе мы написали два return: EXIT\_SUCCESS и EXIT\_FAILURE. EXIT\_SUCCESS и EXIT\_FAILURE --- это макросы, определенные в заголовочном файле stdlib.h (обычно эквивалентные 0 и 1 соответственно).

\begin{CCode}{main.c}
int main(int argc, char *argv[], char *envp[]) { 
	if (open(argv[1], O_RDONLY) < 0) {
		perror("main");			
		return EXIT_FAILURE;
	}	 
				
 	close(argv[1]);
 				
 	return EXIT_SUCCESS;
} \end{CCode}

Дело в том, что после отработки main-функции, return возвращает свое значение чему-то, что инициировало вызов этой самой main. Таким образом, значение return () позволяет инициатору вызова определить корректность (или некорректность) завершения функции. Значение, определяемое в return, принято называть кодом возврата.

\begin{defi}{Код возврата}
	число, возвращаемое родительскому процессу при завершении дочернего, позволяющее сделать выводы о результате выполнения программы.
\end{defi}

Иными словами, код возврата, позволяет кому-то вызывающему программу определить, завершилась ли она корректно, а если нет, то принять какие-нибудь меры (например, изменить входные данные для программы).

\begin{important}
	В отличие от shell, в Си код возврата в случае успеха имеет значение 0 или положительного числа, а в случае ошибки отрицательное значение.
\end{important}

\\
Как мы уже заметили, в приведенной в начале главы программе в return вместо чисел используются макросы EXIT\_SUCCESS и EXIT\_FAILURE из заголовочного файла stdlib.h. Как же правильнее?
	
\begin{CCode}{Указывать в return число}
	int main(int argc, char *argv[], char *envp[]) { 
			/* Actions */
			return 0; 
	} \end{CCode}

или

\begin{CCode}{Указывать в return идетификатор}
	int main(int argc, char *argv[], char *envp[]) { 
			/* Actions */
			return EXIT_SUCCES; 
	} \end{CCode}
		
На самом деле, на подавляющем большинстве систем макрос EXIT\_SUCCESS будет также равен нулю. Однако, мы должны помнить, что если мы будем запускать систему на каком-нибудь контроллере, то его успешный код возврата может быть отличным от нуля.

Таким образом, использование данного макроса делает код более партируемым и кроссплатформенным.


\textbf{Выделение памяти с помощью расширения сегмента данных}

Как уже было сказанно ранее, при запуске процесса ОС выделяет процессу память для размещения кучи, оставляя между кучей и стеком свободное пространство “невыделенной” памяти. При необходимости процесс может запросить дополнительную память, необходимую ему для работы.

Дополнительная память выделяется начиная от старших адресов кучи. При этом указатель верхей границы смещается, тем самым отмечая, что по запрошенным адресам места больше нет.

Смещение границы кучи делается при помощи системных вызовов brk (2) и sbrk (2), которые смещают верхнюю границу кучи, изменяя количество выделенной процессу оперативной памяти. Системные вызовы называются так от слова break, так называется сам указатель --- break pointer.

Системный вызов brk (2) устанавливает верхнюю границу кучи равной аргументу вызова.

\begin{CCode}{brk (2)}
	#include <unistd.h>

	int brk(
		void *endds
	); \end{CCode}

Системный вызов sbrk (2) передвигает верхнюю границу на количество байт, указанное при вызове. Значение может быть и отрицательным, в этом случае размер кучи уменьшится.

\begin{CCode}{sbrk (2)}
	#include <unistd.h>

	void * sbrk(
		intptr_t incr
	); \end{CCode} 

\\[1cm]
\textbf{Выделение новых сегментов из анонимной памяти}

Существует также такое понятие как анонимная память. 

\begin{defi}{Анонимная память}
	область виртуальной памяти, которая не сопоставлена ни с каким файлом.
\end{defi}

Например, у нас есть программа bin.sh, и образ этой программы хранится на диске. Когда мы его загружаем (копируем в оперативную память), он копируется в неанонимную память, потому что образ на диске есть. Если же мы возьмем на куче какой-то кусок и будем им пользоваться, то этот кусок кучи не будет связан с тем, что лежит на системе хранения данных, и это будет называться анонимной памятью. 

Мы можем выделять кусочки анонимной памяти для своего собственного использования. Для этого существует системный вызов mmap (2).

\begin{CCode}{mmap (2)}
	#include <sys/mman.h>

	void *mmap(
		void *addr, 
		size_t len, 
		int prot, 
		int flags, 
		int fildes, 
		off_t off
	); \end{CCode}

Перечислим аргументы mmap:

\begin{itemize}
	\item addr --- желаемый адрес (если установлен 0 или этот адрес не доступен, то система сама выберет адрес);
	\item len  --- количество отображаемых байт;
	\item prot --- разрешающие права доступа к памяти;
		\begin{itemize}
			\item PROT\_READ;
			\item PROT\_WRITE;
			\item PROT\_EXEC;
			\item PROT\_NONE.
		\end{itemize}
	\item flags - специальные флаги
		\begin{itemize}
			\item MAP\_SHARED --- могут использоваться несколько процессов;
			\item MAP\_PRIVATE --- только для вызывающего процесса;
			\item MAP\_FIXED --- выделить память точно с addr.
		\end{itemize}
	\item filedes --- дескриптор файла;
	\item off --- cмещение отображенного участка от начала файла.	
\end{itemize}

Снять отображение сегмента  можно с помощью системного вызова munmap (2). Этот системный вызов принимает адрес начала сегмента и длину сегмента соответственно. 

\begin{CCode}{munmap (2)}
	int munmap(
		void *start, 
		size_t length
	); \end{CCode}

\begin{important}
	Канонически mmap (2) нужен для того, чтобы отобразить файл в память.

	\begin{defi}{Отображение файла в память}
		cпособ работы с файлами, при котором файлу ставится в соответствие участок виртуальной памяти. При этом чтение данных из этих адресов фактически приводит к чтению данных из отображенного файла, а запись данных по этим адресам приводит к записи этих данных в файл.
	\end{defi}

\end{important}
Что нам нужно для простейшего ввода и вывода? Файловый дескриптор, полученный системным вызовом open (2), или дескриптор стандартного потока и буфер, который мы заранее подготовили для данных.

Также нам потребуется указать количество байт, которое мы хотим прочитать или записать.

Для чтения заданного количества байт используется системный вызов read (2), а для записи --- системный вызов write (2). 

\begin{important}
	Оба системных вызова будут смещать файловый указатель на указанное в nbyte количество байт.
\end{important}

\begin{CCode}{read(2)}
	ssize_t read(
		int fildes,	 	/* number of opened file descriptor */ 
		void *buf,	 	/* reading buffer */ 
		size_t nbyte 	/* byte quantity */ 
	); \end{CCode}
Возвращает количество прочитанных байт или код ошибки.

\begin{CCode}{write(2)}
	ssize_t write( 
		int fildes,			 /* number of opened file descriptor */
		const void *buf, 	 /* writting buffer */
		size_t nbyte		 /* byte quantity */
 	); \end{CCode}
Возвращает количество записанных байт или код ошибки.

Помните, что read (2) и write (2) могут вернуть значение меньшее, чем nbyte. Это произойдет в случае, если до конца файла осталось меньше байт, чем мы запросили.

\\
\textbf{Пример чтения/записи.}

Рассмотрим пример чтения/записи с помощью системных вызовов read (2) и write (2).

\begin{CCode}{main.c}	
	#include <unistd.h>
	#include <stdlib.h>

	#define BUF_SIZE 256
	
 	int main(int argc, char *argv[]) { 
		int bytes; 
		char buf[BUF_SIZE];
 
		while((bytes = read(STDIN_FILENO, buf, BUF_SIZE)) > 0) 
			if (write(STDERR_FILENO, buf, bytes) < 0) 
				return EXIT_FAILURE;
		
		return bytes; 
} \end{CCode}

Алгоритм работы примерно следующий: сначала внутри функции main на стеке выделяется переменная bytes, которая  будет хранить количество байт, и буфер размером 256. 

Далее следует цикл, в котором условием продолжения является положительное количество считанных read(2) байт (Условие положительности покрывает и случай возникновение ошибки системного вызова, когда код возврата равен отрицательному числу). В данном случае мы читаем из стандартного потока ввода.

При записи write(2) считанных из STDIN байт в STDERR в условии if, мы также проверим не произошло ли ошибки в процессе работы системного вызова write.

В конце концов мы возвращаем bytes. Если у нас bytes = 0, т.е. read прочитал 0 байт, то фактически файл закончился (это признак конца файла). Если же bytes, какой-то отрицательный, то вернется ненулевой код возврата и мы увидим, что произошла ошибка. 


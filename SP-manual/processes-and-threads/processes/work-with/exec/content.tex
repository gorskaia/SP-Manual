Мы уже сказали, что использование системного вызова vfork (2) рационально в случае дальнейшего запуска функции из семейства exec (3). Функция exec (3) загружает и запускает программу, заданную в аргументе path. Запущенная программа замещает адресное пространство текущего процесса. Все файлы вызывающей программы остаются открытыми и являются доступными новой программе.

Программа должна быть или двоичным исполняемым файлом, или скриптом, начинающимся со строки вида “#! интерпретатор [аргументы]“. 

\begin{CCode}{execle(3)}
	#include <unistd.h>

	int execle( 
		const char *path, 	/* path to file */ 
		const char *arg0, 	/* args */ /* ... */, 
		(char *)0,			/* NULL */ 
		char *const envp[] 	/* environment */ 
	); \end{CCode}

Семейство функций exec (По сути модификации execle)
	execlp() , execvp() , execl(), execv() , execle() , execve() 
		
Значения суффиксов l, v, p и e:

\begin{myenv}{p}{поиск программы по путям переменной окружения PATH. Без суффикса поиск будет производиться только в рабочем каталоге.}
\end{myenv}

\begin{myenv}{l}{показывает, что адресные указатели (arg0, arg1, ..., argn) передаются, как отдельные аргументы.}
\end{myenv}

\begin{myenv}{v}{показывает,  что  адресные  указатели  (arg[0], arg[1],...arg[n]) передаются, как массив указателей.}
\end{myenv}

\begin{myenv}{e}{показывает, что “дочернему“ процессу может быть передан  аргумент   envp (массив с переменными окружения).}
\end{myenv}

\begin{defi}{Сигнал}
	механизм ОС для уведомления процесса о некотором событии. 
\end{defi}

Идея в том, что когда-то возникла необходимость асинхронно отправлять уведомления другому процессу о событии (как бы просто ставить галочку о том, что событие произошло). Для этой задачи и придумали механизм сигналов. 

В случае только межпроцессного взаимодействия ОС не гарантирует доставку сигналов. 

Есть определенное количество сигналов и, в зависимости от операционной системы, это количество меняется. Используя сигналы, нужно понимать, что это может сделать ваш код системно зависимым --- непереносимым.

Стандартных сигналов 16, но в большинстве ОС их немного больше. Они говорят о том, что нужно делать когда приходит сигнал такого типа. Вот некоторые из таких реакций:

\begin{myenv}{SIG\_IGN}{проигнорировать пришедший сигнал.} 
\end{myenv}

\begin{myenv}{SIG\_INT}{завершить процесс.} 
\end{myenv}
	
\begin{myenv}{SIG\_ERR}{завершить процесс с дампом памяти.}
\end{myenv}
	
\begin{myenv}{SIG\_HOLD}{позволяет остановить процесс.}
\end{myenv}

Существуют некоторые немаскируемые сигналы. В первую очередь, это сигнал \textbf{SIG\_KILL}. Дословно --- убить процесс. Однако, существует несколько случаев, при которых после вызова SIG\_KILL сигнал не будет убит сразу же:

\begin{itemize}
	\item когда процесс является зомби;

	\item когда процесс остановлен. Вы можете остановить выполнение процесса, но после того как вы его запустите он все же умрет;

	\item когда процесс находится в вызове системного вызова. До тех пор пока системный вызов не будет завершен сигнал не будет обработан
\end{itemize}

Легкий способ сделать неубиваемый процесс --- взять подключиться по сети к какой-нибудь файловой системе, открыть там файл и начать его читать, а потом физически выключить сервер. Вызов read (2) будет пытаться достучаться до сервера, который не будет отвечать. Убить такой процесс можно только двумя способами: включить сервер или перезагрузить систему. 

\begin{myenv}{SIG\_INT}{прерывание программы, которое обычно посылает эмулятор, поймавший обработку нажатия CTRL+C.}
\end{myenv}

Сигнал \textbf{SIG\_TERM} посылается, когда вы совершаете команду kill PID. Это еще один из тех сигналов, которые нельзя перехватить.

\begin{myenv}{SIG\_STOP}{останавливает процесс. Посылается после нажатия CTRL+Z всем процессам текущей группы. }

\begin{myenv}{SIG\_CONT}{продолжить выполнение, остановленного процесса}

\begin{myenv}{SIG\_ALARM}{вы можете воспользоваться этим сигналом в случае, если вы хотите уведомить сами себя через какое-то время, что ваше время истекло.}

\begin{myenv}{SIG\_PIPE}{вы можете получить данный сигнал, когда ваш сокет был неожиданно завершен второй стороной по какой-либо причине.}

\textbf{Сигналы SIG\_USR1 и SIG\_USR2} --- два стандартных сигнала, которые по умолчанию приводят к завершению процесса. Это такой способ послать уведомление процессу о том, что произошло что-то не предусмотренное стандартным поведением системы. 